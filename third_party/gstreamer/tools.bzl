"""Custom Starlark macros and rules used to build gstreamer."""

def gen_config_file(name, out, defs = {}, undefs = [], **kwargs):
    """Macro to generate top level config.h for each subproject.

    This macro is meant to be used in blaze where gstreamer uses
    meson's configuration_data and configuration_file to produce
    a configuration header.

    Args:
     name: Name for the rule.
     out: The name of the generated config header.
     defs: Dictionary containing the #define's. The keys are the
           names to be defined, and the values are the values.
     undefs: List containing the #undefs's.
     **kwargs: Keyword args to forward to genrule.
    """

    contents_list = [
        "// Autogenerated config header.",
        "#pragma once",
    ]

    for k, v in defs.items():
        def_string = "#define {}".format(k)
        if v != "":
            def_string += " {}".format(v)
        contents_list.append(def_string)

    for v in undefs:
        undef_string = "#undef {}".format(v)
        contents_list.append(undef_string)

    echo_string = "\n\n".join(contents_list)

    native.genrule(
        name = name,
        outs = [out],
        cmd = "echo '{}' > $@".format(echo_string),
        **kwargs
    )

def specialize_file_template(name, src, out, replacements = {}, **kwargs):
    """Macro to specialize *.in template files.

    The Gstreamer code base has template files whose names have the suffix .in.
    These files contain strings that are intended to be replaced during the meson
    configuration step.

    This macro will do what meson does to these files; that is, to specialize them
    into a form that can be used for the real build.

    This macro simply takes a template file in `src`, and makes all the
    string replacements specified in the mapping `replacements`, and saves the
    result in the new file specified in `out`.

    `replacements` is a dictionary whose keys are the strings you want to replace
    and whose values are what you want want them to be replaced with. They
    must be properly escaped for the sed command.

    Args:
     name: Name for the rule.
     src: The name of the template file. Usually ends with suffix .in.
     out: The name of the specialized file.
     replacements: Dictionary containing string replacement mappings.
     **kwargs: Keyword args to forward to genrule.
    """
    sed_list = []
    for k, v in replacements.items():
        sed_list.append("s/{}/{}/g".format(k, v))
    sed_string = ";".join(sed_list)
    native.genrule(
        name = name,
        srcs = [src],
        outs = [out],
        cmd = "sed '{}' $< > $@".format(sed_string),
        **kwargs
    )

# This adapts the logic in
# https://github.com/mesonbuild/meson/blob/master/mesonbuild/modules/gnome.py
#
# It generates both the .h and .c files in one command, just like
# gnome.mkenums_simple does.
def _gnome_mkenums_simple_impl(ctx):
    fhead = ("#pragma once\n\n" +
             '#include "third_party/glib/glib/glib-object.h"\n' +
             "{header_prefix}\n\n" +
             "G_BEGIN_DECLS\n")
    fhead = fhead.format(header_prefix = ctx.attr.header_prefix)

    fprod = '\n/* enumerations from "@basename@" */\n'

    vhead = ("\n{decl_decorator}\n" +
             "GType {func_prefix}@enum_name@_get_type (void);\n" +
             "#define @ENUMPREFIX@_TYPE_@ENUMSHORT@ ({func_prefix}@enum_name@_get_type())\n")
    vhead = vhead.format(
        decl_decorator = ctx.attr.decorator,
        func_prefix = ctx.attr.function_prefix,
    )

    ftail = "\nG_END_DECLS\n"

    args = ctx.actions.args()
    args.add("--output", ctx.outputs.hdr_out)
    args.add("--fhead", fhead)
    args.add("--fprod", fprod)
    args.add("--vhead", vhead)
    args.add("--ftail", ftail)
    args.add_all(ctx.files.sources)
    ctx.actions.run(
        inputs = ctx.files.sources,
        outputs = [ctx.outputs.hdr_out],
        executable = ctx.executable._glib_mkenums,
        arguments = [args],
        mnemonic = "GnomeMkenumsSimpleHdr",
        progress_message = "Generating {}".format(ctx.outputs.hdr_out.basename),
    )

    fhead = ""
    if ctx.attr.body_prefix:
        fhead += "{}\n".format(ctx.attr.body_prefix)
    fhead += '#include "{}"\n'.format(ctx.outputs.hdr_out.short_path)
    for hdr in ctx.files.sources:
        fhead += '#include "{}"\n'.format(hdr.short_path)
    fhead += ("\n#define C_ENUM(v) ((gint) v)\n" +
              "#define C_FLAGS(v) ((guint) v)\n")

    fprod = '\n/* enumerations from "@basename@" */\n'

    vhead = ("\nGType\n" +
             "{func_prefix}@enum_name@_get_type (void)\n" +
             "{{\n" +
             "static gsize gtype_id = 0;\n" +
             " static const G@Type@Value values[] = {{\n")
    vhead = vhead.format(func_prefix = ctx.attr.function_prefix)

    vprod = '    { C_@TYPE@(@VALUENAME@), "@VALUENAME@", "@valuenick@" },'

    vtail = """    { 0, NULL, NULL }
  };
  if (g_once_init_enter (&gtype_id)) {
      GType new_type = g_@type@_register_static (g_intern_static_string ("@EnumName@"), values);
      g_once_init_leave (&gtype_id, new_type);
  }
  return (GType) gtype_id;
}
"""

    args = ctx.actions.args()
    args.add("--output", ctx.outputs.src_out)
    args.add("--fhead", fhead)
    args.add("--fprod", fprod)
    args.add("--vhead", vhead)
    args.add("--vprod", vprod)
    args.add("--vtail", vtail)
    args.add_all(ctx.files.sources)
    ctx.actions.run(
        inputs = ctx.files.sources,
        outputs = [ctx.outputs.src_out],
        executable = ctx.executable._glib_mkenums,
        arguments = [args],
        mnemonic = "GnomeMkenumsSimple",
        progress_message = "Generating {}".format(ctx.outputs.src_out.basename),
    )

    return [
        DefaultInfo(files = depset([ctx.outputs.hdr_out, ctx.outputs.src_out])),
    ]

# These attributes map almost exactly to those of gnome.mkenums_simple.
_gnome_mkenums_simple_attrs = {
    "body_prefix": attr.string(
        doc = "Same as `body_prefix` in meson's gnome.mkenums_simple.",
    ),
    "decorator": attr.string(
        doc = "Same as `decorator` in meson's gnome.mkenums_simple.",
    ),
    "function_prefix": attr.string(
        doc = "Same as `function_prefix` in meson's gnome.mkenums_simple.",
    ),
    "header_prefix": attr.string(
        doc = "Same as `header_prefix` in meson's gnome.mkenums_simple.",
    ),
    "identifier_prefix": attr.string(
        doc = "Same as `identifier_prefix` in meson's gnome.mkenums_simple.",
    ),
    "sources": attr.label_list(
        mandatory = True,
        allow_files = True,
        doc = "The set of inputs to search for enum definitions. " +
              "Same as `sources` in meson's gnome.mkenums_simple.",
    ),
    "symbol_prefix": attr.string(
        doc = "Same as `symbol_prefix` in meson's gnome.mkenums_simple.",
    ),
    "hdr_out": attr.output(
        mandatory = True,
        doc = "The generated header file.",
    ),
    "src_out": attr.output(
        mandatory = True,
        doc = "The generated source file.",
    ),
    "_glib_mkenums": attr.label(
        default = Label("//third_party/glib/gobject:glib_mkenums"),
        executable = True,
        cfg = "exec",
    ),
}

# This command mimics the meson command gnome.mkenums_simple:
# https://mesonbuild.com/Gnome-module.html#gnomemkenums_simple
#
# It automatically generates enum support libraries by using
# `glib-mkenums` (Ported into Google3 at
# //third_party/glib/gobject/glib-mkenums.py)
#
# glib-mkenums by itself is very flexible and free form. However,
# most projects have a very specific form. Hence, meson supports
# this common case through a more opinionated "simple" path, which
# just calls glib-mkenums in a specific way.
gnome_mkenums_simple = rule(
    _gnome_mkenums_simple_impl,
    attrs = _gnome_mkenums_simple_attrs,
    output_to_genfiles = True,
)
